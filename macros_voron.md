# Написание макросов Klipper
Следующее руководство - это моя попытка объяснить, как работают макросы Klipper1 и как писать макросы. В основном оно основано на моих знаниях, полученных из чтения документации Klipper, экспериментов и информации из Klipper Discord.

Предупреждение В приведенном ниже руководстве приведены примеры GCode и макросов. Они приведены только в иллюстративных целях и не предназначены для использования на реальном оборудовании. Пожалуйста, не копируйте примеры в свои рабочие конфигурации.

### Что такое макросы?
Макросы представляют собой набор команд GCode2, которые Klipper выполняет как единое целое при выполнении макроса. Макросы могут содержать любые допустимые команды GCode, и при запуске весь макрос выполняется до завершения.

Поскольку Klipper фактически однопоточный, одновременно может выполняться только один макрос (подробнее об этом см. delayed_gcode).

Макросы - это удобный способ запустить произвольное количество команд GCode одним щелчком мыши.

## Структура макроса
Немного о разделах
Файлы конфигурации Klipper разделены на разделы. У каждого раздела есть заголовок, с которого начинается раздел. Разделы заканчиваются, когда определяется другой раздел или заканчивается файл.

Разделы содержат несколько пар ключ / значение, разделенных символами ‘:’ или ‘=’. Значения могут занимать несколько строк, если во всех строках отступ глубже исходной строки. Это особенно важно для макросов, поскольку они обычно состоят из нескольких команд GCode, каждая в отдельной строке.

### Базовая структура команды GCode
Чтобы лучше понимать макросы, полезно понимать структуру / синтаксис команд GCode.

Команды GCode состоят из имени команды и, при необходимости, списка параметров. Команды GCode отображаются по одной в строке, где строка начинается с имени команды GCode, за которым следуют любые параметры и, возможно, комментарий в конце строки:

    G0 X10 Y10 Z10 F3600 ; Move to X=10, Y=10, Z=10 at 3600 mm/min

В приведенном выше примере G0 - это название команды GCode, X10 Y10 Z10 F3600 - параметры команды и ; Move to X=10, Y=10, Z=10 at 3600 mm/min - комментарий после команды. (Символ ; сообщает любому процессору GCode, что начинается комментарий и что все, что следует за ним, может быть проигнорировано.)

Команды GCode не обязательно должны иметь аргументы. Некоторые команды GCode даже не принимают параметры, поскольку они им не нужны. Например, G90 или G91. Кроме того, не все допустимые параметры должны быть указаны. Например, G0 команда принимает X, Y, Z и F в качестве параметров, но G0 команда может указывать любое их подмножество:

    G0 X20 ; Move to X20 maintaining current Y and Z coordinates.

### Макросы
Макросы определяются в [gcode_macro] разделе. Вы можете ознакомиться с полной документацией Klipper для gcode_macro раздела здесь.

Обычно макрос принимает следующую форму:

    [gcode_macro <MACRO_NAME>]
    gcode:
        <GCode command>
        ...

<MACRO_NAME> имя может быть любым по вашему желанию. Допустимыми символами являются буквенно-цифровые символы и подчеркивание. Обычно имя макроса пишется заглавными буквами, но это не обязательно. Числа могут отображаться только в конце имен макросов. Имена макросов, начинающиеся с подчеркивания (‘_’), являются “скрытыми”. Они по-прежнему определены и могут вызываться, но не показаны во внешних интерфейсах, таких как Mainsail или Fluidd.

Макросы вызываются / запускаются либо из интерфейса, либо из других макросов. Чтобы запустить макрос из другого макроса, вызовите его в соответствующее время. Например:

    [gcode_macro MACRO1]
    gcode:
        G28 ; home all axis

    [gcode_macro MACRO2]
        gcode:
            # Home the printer first
            MACRO1
            G0 X0 Y0

В приведенном выше примере MACRO2 срабатывает MACRO1 при выполнении первой команды. Это приведет к тому, что MACRO1 будет выполнено полностью, прежде чем MACRO2 перейти к следующей команде GCode.

## ЕЩЕ НЕМНОГО О МАКРОСАХ И О ТОМ, КАК ИХ ВЫЗЫВАТЬ
Когда макрос определяется с помощью [gcode_macro MACRO_NAME], набор команд GCode, которые находятся в теле макроса, группируются вместе и им присваивается метка MACRO_NAME. С этого момента MACRO_NAME становится псевдо-командой GCode, которую распознает Klipper. Как таковой, он может использоваться любым способом, который можно использовать для выполнения команд GCode - консоль Mainsail, Moonraker API, файлы GCode и т.д. Также, как и любая другая команда GCode, макросы могут быть созданы для приема параметров (см. (Базовая структура команды GCode) [#базовая структура команды gcode] и (Параметры шаблона макрокоманды) [#параметры шаблона макрокоманды]) или нет.

Важно помнить, что Klipper обрабатывает макросы как команды GCode, чтобы лучше понимать, как Klipper выполняет операции последовательности.

Klipper завершает каждую команду GCode перед выполнением другой. Невозможно выполнить две отдельные команды GCode одновременно. Поскольку макросы рассматриваются как команды GCode, на них распространяется одно и то же правило - макрос должен завершиться до выполнения следующей команды GCode. Итак, несмотря на то, что макросы состоят из множества других команд GCode, Klipper не может вставлять / выполнять другие команды GCode во время выполнения макроса.

### Переменные
Макропеременные (variable_<name> пара ключ / значение) - это постоянные переменные, назначенные макросу. Их значения могут использоваться / устанавливаться внутри макроса или даже из другого макроса. Вы можете думать о них как о глобальных переменных, специфичных для макросов.

    [gcode_macro MACRO3]
    variable_var1: 0
    gcode:

Приведенный выше пример определяет макропеременную var1 с начальным значением 0. Это значение будет присвоено переменной при запуске Klipper и инициализации всех макрообъектов. Если значение переменной будет изменено позже, новое значение будет сохраняться до тех пор, пока не будет изменено снова.

На переменные, определенные макрокомандой, можно ссылаться непосредственно из макроса:

    [gcode_macro MACRO4]
    variable_var1: 0
    gcode:
        M117 Var1 is equal to {var1}

Для ссылки на макропеременные из другого макроса требуется поиск макро-объекта, который определяет нужные переменные:

    [gcode_macro MACRO5]
    gcode:
        {% set macro2 = printer["gcode_macro MACRO2"] %}
        M117 Var1 from MACRO2 is set to {macro2.var1}

Изменение значений переменных во время выполнения выполняется с помощью команды SET_GCODE_VARIABLE:

    [gcode_macro MACRO6]
    gcode:
        SET_GCODE_VARIABLE MACRO=MACRO2 VARIABLE=var1 VALUE=10

Пожалуйста, обратите внимание, что команда SET_GCODE_VARIABLE должна использоваться независимо от того, изменяется ли переменная в определяющем макросе или в другом.

### Пользовательские настройки макросов
Поскольку Klipper допускает определение “пустого” макроса - макроса, который не содержит никаких команд GCode, может быть создан макрос, представляющий собой обычное хранилище для различных настроек / значений:

    [gcode_macro _USER_VARIABLES]
    variable_var1: 0
    variable_var2: 1
    gcode:
    
    [gcode_macro MACRO7]
    gcode:
        {% set user_vars = printer["gcode_macro _USER_VARIABLES"] %}
        M117 Variable 1: {user_vars.var1}
        M117 Variable 2: {user_vars.var2}
    
В приведенном выше примере создается скрытый макрос с именем _USER_VARIABLES, который используется только для хранения переменных. Затем другие макросы могут ссылаться на него для использования и / или установки значений переменных.

Это обычная схема использования для многих конфигураций, например, в сообществе Voron.

### Организация файлов конфигурации
Макросы обычно размещаются в файлах конфигурации - файлах с .cfg расширением, расположенных в каталоге конфигурации (обычно /home/pi/printer_data/config). Макросы можно поместить все в один большой файл или разделить на несколько файлов, каждый из которых содержит макросы и конфигурацию, специфичную для определенной функции / конфигурации.

Обычно Klipper ищет файл с именем printer.cfg в каталоге конфигурации. Этот файл служит файлом конфигурации верхнего уровня. Многие пользователи просто помещают всю свою конфигурацию и макросы в этот единственный файл.

Если конфигурация распределена по нескольким файлам, файлы конфигурации должны быть включены в printer.cfg. Это делается с помощью [include] директивы. Эта директива предписывает Klipper включить указанный файл в свою конфигурацию. [include] директивы могут быть размещены в любом файле, и Klipper включит указанный файл при обработке текущего файла конфигурации. Это позволяет создавать вложенную конфигурацию.

Даже если макросы разбиты на несколько файлов конфигурации, Klipper создает единую конфигурацию для принтера. Это означает, что все макросы, определенные во всех файлах конфигурации, определены и доступны. Следовательно, любой определенный макрос может вызываться / запускаться из любого другого макроса.

### Шаблоны макросов
Шаблоны макросов3 - это способ динамического изменения того, что делает макрос, на основе некоторых условий или логики. Klipper предоставляет способ изменять команды GCode, выполняемые путем обертывания наборов команд управляющими операторами на основе языка шаблонов Jinja24.

Шаблоны макросов могут немного сбивать с толку, потому что кажется, что они предлагают возможность создавать нестатические макросы (макросы, которые изменяют то, что они делают, в зависимости от некоторого условия). Это верно лишь частично. Язык шаблонов Jinja2 является всего лишь препроцессором макросов.

Klipper вычисляет макрос при запуске / вызове макроса. В этот момент вычислитель обрабатывает условия и генерирует тело макроса (набор команд, которые будет выполнять макрос). После оценки набор команд, выполняемых макрокомандой, не может быть изменен до тех пор, пока макрос не будет запущен / вызван снова. Это означает, что нет способа изменить содержимое макрокоманды в зависимости от меняющихся условий печати.

Ниже приведен пример, иллюстрирующий это. Рассмотрим следующий пример макроса:

    [gcode_macro EXAMPLE]
    gcode:
        M109 S200
        {% for i in range(5) %}
            {% if printer.extruder.temperature < 100 %}
                M117 HEATING...
            {% else %}
                M117 Done.
            {% endif %}
        {% endfor %}
    
Обычно ожидается, что приведенный выше макрос пять раз выведет “Готово” на консоль, поскольку команда M109 S200 гарантирует, что температура экструдера достигнет 200C до начала цикла. Следовательно, условие внутри цикла всегда будет false . Ожидаемый поток GCode будет:

    M109 S200
    M117 Done.
    M117 Done.
    M117 Done.
    M117 Done.
    M117 Done.
    
Однако, как описано выше, вычисление макроса Klipper происходит при запуске макроса, и это происходит только один раз. Шаблонная часть макроса выполняется до выполнения любой из команд GCode, перечисленных в макросе. Следовательно, если макрос запускается, когда экструдер холодный, команда M109 S200 еще не была бы выдана, и температура экструдера, используемая в условии, была бы температурой окружающей среды. Следовательно, условие внутри цикла всегда будет true. Фактический GCode, сгенерированный steam, будет:

    M1109 S200
    M117 HEATING...
    M117 HEATING...
    M117 HEATING...
    M117 HEATING...
    M117 HEATING...
    
Изучение языка шаблонов Jinja2 выходит за рамки данного руководства. Однако ниже приведено несколько примеров с описаниями:

### Настройка внутренних переменных
    [gcode_macro EXAMPLE1]
    gcode:
        {% set var1 = printer.toolhead.axis_maximum.x %}
        G0 X{var1}
    
В приведенном выше примере шаблон создает переменную с именем var1 и присваивает максимальное положение оси X5. It использует переменную для перемещения инструментальной головки в указанное положение вдоль оси X.

Условия
    [gcode_macro EXAMPLE1]
    gcode:
        {% set var1 = printer.toolhead.axis_maximum.x %}
        {% set var2 = printer.toolhead.position.x %}
    
        {% if var2 < var1 %}
            G0 X{var1}
        {% endif %}
    
В приведенном выше примере шаблон создает одну переменную (var1) для удержания максимального положения оси X и другую (var2) для удержания текущего положения инструментальной головки вдоль оси X. Затем он проверяет, меньше ли текущее положение, чем максимальное, и если да, перемещает инструментальную головку в максимальное положение.

### Циклы
Поскольку шаблоны макросов оцениваются только один раз, перед выполнением любых команд GCode из макроса, язык шаблонов предоставляет ограниченные возможности для выполнения цикла (многократного выполнения набора команд). Например, язык шаблонов не предоставляет while цикл, поскольку такой цикл зависел бы от оценки изменяющихся условий, что невозможно.

    [gcode_macro EXAMPLE3]
    gcode:
        {% set var1 = 10 %}
        {% set var2 = printer.toolhead.axis_maximum.x %}
        {% set var3 = printer.toolhead.axis_maximum.y %}
    
        G28
        G0 X0 Y0 Z10
        {% for i in range(var1) %}
            G0 X{var2} Y{var3}
            G0 X0 Y0
        {% endfor %}
    
В этом примере используются 3 переменные:

    var1, который содержит значение “10”.
    var2, которая удерживает максимальное положение оси X.
    var3, который удерживает максимальное положение оси Y.
    После определения переменных принтер устанавливается на место (G28), а инструментальная головка перемещается в исходное положение, на 10 мм выше монтажной пластины (G0 X0 Y0 Z10).

Затем макрос повторяет команды

    G0 X{var2} Y{var3}
    G0 X0 Y0

10 раз (значение var1), при котором головка инструмента перемещается в противоположный угол и возвращается к исходной точке.

### Параметры шаблона макроса
Klipper предоставляет вызывающим пользователям (интерфейсам или другим макросам) возможность передавать параметры в макросы. Документация Klipper уже включает довольно хороший раздел о передаче параметров макроса. Его можно найти по ссылке https://www.klipper3d.org/Command_Templates.html?h=params#macro-parameters.

Параметры передаются через params объект, который автоматически предоставляется и заполняется Klipper. Если макросу требуются параметры, он может использовать params объект, как показано ниже.:

    [gcode_macro EXAMPLE4]
    gcode:
        {% set var1 = params.VALUE1 %}
    
Затем вызывающие пользователи могут запускать макрос как таковой:

    EXAMPLE1 VALUE1=<value>

Значение, установленное для VALUE1 параметра, будет автоматически доступно на сайте params.VALUE1.

Значения параметров всегда хранятся в виде строк. Следовательно, может потребоваться выполнить преобразование в более подходящий тип (integer, float, list и т.д.). Это можно сделать с помощью фильтров Jinja6. Фильтры применяются к значениям с помощью оператора pipe (|). Хотя полное обсуждение фильтров выходит за рамки данного руководства, распространенными фильтрами являются int, float, split.

    [gcode_macro EXAMPLE5]
    gcode:
        {% set var_int = params.INT_VALUE|int %}
        {% set var_float = params.FLOAT_VALUE|float %}
        {% set var_list = params.LIST_VALUE|split(",") %}
    
Еще одним полезным фильтром является default() filter, который присваивает параметру значение по умолчанию:

    [gcode_macro EXAMPLE6]
    gcode:
        {% set var_int = params.INT_VALUE|default(5)|int %}
        {% set var_float = params.FLOAT_VALUE|default(2.5)|float %}
    
Разница между EXAMPLE5 и EXAMPLE6 заключается в том, что EXAMPLE5 при запуске макроса требуется установка параметров. В противном случае Klipper выдаст ошибку из-за отсутствия параметров. С другой стороны, EXAMPLE6 может вызываться без использования каких-либо параметров, и в этом случае будут использоваться значения по умолчанию, предоставленные default() фильтром.

Как вы можете видеть, фильтры можно подключать один за другим, чтобы обеспечить более полный контроль над значениями и типами параметров.

### Отложенный GCode
Макросы с отложенным GCode7 - это способ запланировать выполнение макроса на более позднее время. В основном они такие же, как обычные макросы, за следующими исключениями:

Единственными допустимыми парами ключ / значение являются gcode и initial_duration.
Они не могут определять переменные.
Они не принимают параметры.
К сожалению, это делает их немного менее гибкими, чем обычные макросы, хотя существует обходной путь для передачи параметров макросам с задержкой.

Чтобы определить отложенный макрос GCode, используйте [delayed_gcode] раздел:

    [delayed_gcode DELAYED_GCODE_MACRO1]
    gcode:
        M117 Delayed GCode macro triggered.

Планирование отложенного макроса GCode выполняется командой UPDATE_DELAYED_GCODE:

    UPDATE_DELAYED_GCODE ID=<delayed GCode macro name> DURATION=<delay before execution>

DURATION Значение указано в секундах. Оно указывает количество секунд с момента выполнения UPDATE_DELAYED_GCODE команды до запуска отложенного макроса GCode. Например, чтобы запланировать запуск макроса DELAYED_GCODE_MACRO1 на 5 секунд в будущем, команда будет:

    UPDATE_DELAYED_GCODE ID=DELAYED_GCODE_MACRO1 DURATION=5

Отменить отложенный GCode, который уже был запланирован, можно, установив DURATION значение 0. Попытка отменить отложенный макрос GCode, который еще не был запланирован, не является ошибкой.

### Передача параметров в отложенный GCode
Хотя невозможно передать переменные и / или параметры в макросы отложенного GCode напрямую, есть косвенный способ сделать это - используя переменные, определенные другим макрокомандой (см. Настройки пользовательского макроса):

    [gcode_macro __PARAMETERS]
    variable_var1: 0
    variable_var2: 10
    
    [delayed_gcode DELAYED_GCODE_MACRO2]
    gcode:
        {% set parameters = printer["gcode_macro __PARAMETERS] %}
        M117 var1 = {var1}, var2 = {var2}
    
    [gcode_macro SCHEDULE_DELAYED]
    gcode:
        SET_GCODE_VARIABLE MACRO=__PARAMETERS VARIABLE=var1 VALUE=20
        SET_GCODE_VARIABLE_MACRO=__PARAMETERS VARIABLE=var2 VALUE=40
        UPDATE_DELAYED_GCODE ID=DELAYED_GCODE_MACRO2 DURATION=10

В приведенном выше примере используются несколько функций макросов Klipper:

“Скрытые” макросы, которые не отображаются во интерфейсах.
Переменные макроса.
Возможность ссылаться на переменные макроса из других макросов.
Возможность задавать переменные макроса из других макросов.
Базовые макросы
Одним из наиболее распространенных применений макросов с отложенным GCode является создание ”фоновых" макросов - макросов, которые выполняются несколько асинхронно в фоновом режиме. Это делается путем создания отложенного макроса GCode таким образом, чтобы он повторно планировал себя в зависимости от текущих условий. Это возможно, потому что Klipper обновляет текущее состояние принтера непосредственно перед выполнением макроса. Ниже приведен простой пример этого:

    [delayed_gcode DELAYED_GCODE_MACRO3]
    gcode:
        {% set current_temp = printer[printer.toolhead.extruder].temperature %}
        {% set target_temp = printer[printer.toolhead.extruder].target %}
    
        {% if current_temp < target_temp> %}
            M117 Still heating...
            UPDATE_DELAYED_GCODE ID=DELAYED_GCODE_MACRO3 DURATION=1
        {% else %}
            M117 Target temperature reached
            UPDATE_DELAYED_GCODE ID=DELAYED_GCODE_MACRO3 DURATION=0
        {% endif %}
    
    [gcode_macro HEAT_EXTRUDER]
    gcode:
        M104 S240
        UPDATE_DELAYED_GCODE ID=DELAYED_GCODE_MACRO3 DURATION=1

Приведенный выше пример показывает, как макросы с отложенным GCode можно использовать для реализации псевдо-while цикла. При запуске HEAD_EXTRUDER макрос установит температуру экструдера на 240 градусов и запланирует DELAYED_GCODE_MACRO3 выполнение через 1 секунду.

Когда DELAYED_GCODE_MACRO3 выполняется, он будет искать текущую и целевую температуру экструдера. Если текущая температура меньше целевой, он повторно запланирует свой запуск через 1 секунду. В противном случае он отменит сам себя.

Предупреждение Будьте осторожны при использовании описанного выше механизма для создания фоновых макросов. В большинстве случаев сложно реализовать точное желаемое поведение из-за ограничений, налагаемых макросами Klipper и delayed GCode.

Сохранение и восстановление состояния GCode
Состояние GCode Klipper - это текущее состояние анализатора GCode. Состояние включает следующие настройки:

Режим координат GCode (абсолютный или относительный).
Режим выдавливания (абсолютный или относительный).
Происхождение.
Смещение Z.
Переопределения скорости и выдавливания.
Скорость перемещения.
Текущее положение сопла.
Относительное положение экструдера.
Сохранение состояния GCode позволяет другим макросам выполнять действия, не влияя на состояние предыдущих макросов. Это особенно полезно для таких макросов, как PAUSE и RESUME - PAUSE макрос сохраняет состояние GCode, когда печать была приостановлена, а RESUME макрос восстанавливает его. Это предотвращает вмешательство любого GCode, выполняемого между макросами PAUSE и RESUME (например, макросы замены нити накала, макросы очистки сопел и т.д.), или разрушение состояния, в котором находился принтер на момент приостановки.

Сохранение и восстановление состояния GCode выполняется с помощью команд SAVE_GCODE_STATE8 и RESTORE_GCODE_STATE9. При сохранении состояния SAVE_GCODE_STATE команда принимает NAME аргумент. Затем на сохраненное состояние можно ссылаться, используя это имя. Это позволяет осуществлять вложение этих команд.

После выполнения команды SAVE_GCODE_STATE NAME=<name> текущее состояние GCode сохраняется под именем “". Когда имя RESTORE_GCODE_STATE =`команда выполнена, состояние сохранено как "" восстановлено. Все изменения перечисленных выше настроек, внесенные командами `SAVE_GCODE_STATE" и "RESTORE_GCODE_STATE", будут утеряны (если только они не были сохранены под другим именем).

Предупреждение Использование команд сохранения / восстановления должно выполняться осторожно и намеренно. Состояние, которое изменилось между двумя командами, может быть потеряно, что может привести к неожиданным результатам. Одним из примеров этого является использование функции сохранения / восстановления в PRINT_START макросах. Действие, выполняемое PRINT_START макрокомандой, обернутой набором SAVE_GCODE_STATE/RESTORE_GCODE_STATE команд, может быть потеряно после восстановления предыдущего состояния.

Например, если одна из задач, которую выполняет PRINT_START макрос, - это настройка смещения Z для определенного типа нити накала или поверхности печати, вновь установленное смещение Z будет потеряно, когда PRINT_START макрос завершится.

### Макросы и слайсеры
При первом создании или настройке нового принтера пользователю, вероятно, в первую очередь потребуется изменить макросы Klipper, это PRINT_START и / или PRINT_END макросы.

Эти два макроса обычно используются для выполнения всех операций по подготовке к печати (PRINT_START) или для завершения печати (PRINT_END). Такие операции могут включать наведение, выравнивание слоя, создание сетки слоя, предварительный нагрев сопла, слоя или камеры и т.д.

Обычно это принимает форму добавления кода в макрос для выполнения желаемых операций. Однако частой проблемой, с которой сталкиваются пользователи, является необходимость передачи информации из слайсера на принтер.

Профили слайсера определяют параметры принтера, нити (ов) и отдельной печати. Затем эти параметры используются для генерации соответствующих команд GCode для печати.

Передача значений, настроек и т.д. Из слайсера на принтер может принимать множество различных форм, обычный способ сделать это - использовать параметры макроса для передачи значений в PRINT_START макрос. Такие значения могут включать температуру слоя и экструдера, температуру камеры, тип используемой нити накала и т.д.

Передача значений из слайсера так же проста, как вызов PRINT_START макроса в начале созданного GCode. У каждого часто используемого слайсера есть способ для пользователя предоставить пользовательский GCode, который будет вставлен в начале выходного файла. У каждого слайсера также должен быть способ ссылаться на настройку слайсера с помощью этого пользовательского GCode. На данном этапе передача информации на принтер - это всего лишь вопрос вызова PRINT_START с параметром макроса для каждой из интересующих настроек слайсера.

Более подробная информация о передаче значений из срезов в Klipper
Ниже приведены несколько примеров для некоторых распространенных слайсеров.

ПРЕДУПРЕЖДЕНИЕ То, что показано ниже, - всего лишь примеры. Пожалуйста, не используйте GCode вслепую. Убедитесь, что используются правильные настройки / заполнители.

#### PrusaSlicer / SuperSlicer
В PrusaSlicer (PS) и SuperSlicer (SS) есть несколько мест, куда можно добавлять пользовательский GCode, в зависимости от того, на что влияет этот GCode. Для макроса PRINT_START место, куда нужно добавить пользовательский G-код, находится в разделе “Запустить G-код” в разделе “Настройки принтера -> Пользовательский G-код”.

PRINT_START EXTRUDER_TEMP={first_layer_temperature[initial_extruder]} BED_TEMP=[first_layer_bed_temperature] CHAMBER_TEMP=[chamber_temperature]

В приведенном выше примере будет вызван макрос PRINT_START в начале файла GCode, передающий температуру экструдера, слоя и камеры, как определено в используемом профиле слайсера. Чтобы позволить слайсеру заменять фактические значения, команда использует “заполнители”10. При выводе окончательного GCode PS / SS заменит фактические значения вместо заполнителей. Например, если используемый профиль определяет температуру экструдера как 240 ° C, температуру слоя как 75 ° C и температуру камеры как 40 ° C, команда, появляющаяся в файле GCode, будет иметь вид:

    PRINT_START EXTRUDER_TEMP=240 BED_TEMP=75 CHAMBER_TEMP=40

#### Cura
Место, где можно добавить аналогичный пользовательский G-код в Cura, находится в окне “Запустить G-код” на экране “Настройки устройства -> Принтер”.

    PRINT_START EXTRUDER_TEMP={material_print_temperature_layer_0} BED_TEMP={material_bed_temperature_layer_0} CHAMBER_TEMP={build_volume_temperature}

GCode Cura очень похож, за исключением имен-заполнителей11.

