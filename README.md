# Учебник по макросам для Klippera
Makros Klipper Tutorial - https://klipper.discourse.group/t/macro-creation-tutorial/30/2
21 марта 2021 года

## Часть 1: Основные концепции программирования

Макросы Klipper довольно мощные, но в то же время могут быть ограничены в своей
области применения. Идея макросов заключается в том, чтобы иметь возможность принимать некоторые базовые решения и действовать
в соответствии с ними, заменяя различные значения другими значениями. Однако, чтобы понять макросы,
мы должны сначала понять некоторые основы программирования

### Что такое функция?

Функция - это фрагмент кода, который выдает выходные данные на основе входных данных. Обычно
решения принимаются внутри функции с помощью выражений, которые определяют, что должна делать
функция. Функции также могут называться методами, подпрограммами, процедурами.
Все они делают в основном одно и то же: берут блок кода и присваивают ему имя
, чтобы его можно было повторно использовать для создания выходных данных на основе входных данных.

### Что такое литерал?

Литерал - это значение, которое фактически жестко запрограммировано и не может быть изменено
на протяжении выполнения программы. Например, целочисленное значение 42 является
литералом. Значение 42 буквально 42.

### Что такое комментарий?

Комментарий предназначен для того, чтобы человек, пишущий код, оставлял
заметки для себя или кого-либо еще, если он вернется и попытается понять
код позже. Комментарии обозначаются специальным символом или набором символов,
специфичных для каждого языка программирования. В случае конфигурационных файлов Klipper и
макросов для обозначения комментария используются два таких символа. # и ; . Когда
любой из них появляется в строке, все, что находится после них, будет проигнорировано.

	#Move the toolhead to the middle of the bed
	G1 X150 Y150
	
	#Move the toolhead up slightly
	G1 Z1
Комментарии также могут быть полезны при отладке или изменении кода. Если у вас
есть фрагмент кода, который, возможно, работает неправильно, или вы хотите попробовать его переделать
сделайте что-нибудь еще, но не хотите удалять исходный фрагмент, если это не сработает
работая, вы можете “закомментировать” этот фрагмент кода

	#Move the toolhead to the middle of the bed
	#G1 X150 Y150
	
	#Move the toolhead up slightly
	G1 Z1
В приведенном выше примере только что прокомментированная строка будет проигнорирована, когда придет время
время выполнения макроса.

### Что такое переменная?

Переменная - это значение, которое может изменяться на протяжении выполнения программы.
Переменные обычно представлены именами или буквами. Имя связано
со значением, потому что значение может изменяться. Когда на имя переменной ссылаются
во время выполнения блока кода, имя заменяется на
значение переменной во время выполнения выражения. Итак, если мы возьмем
наш литерал 42 и присвоим его переменной, вызываемой e всякий раз, когда e на
ссылаются, будет использоваться значение 42.

### Что такое задание?

Присвоение значения переменной выполняется путем присваивания. Это может быть буквальное значение,
значение другой переменной или результат выражения. Присвоение выполняется путем
установки переменной, равной значению. В синтаксисе Jinja2 это делается с помощью

	{ set x = 42 }
 
### Что такое выражение?

Выражение - это команда программирования, которая что-то делает. Простым примером
может быть команда gcode. M105 это выражение gcode, которое сообщает о различных
температурах. Присвоение переменной также является выражением. Сравнение
двух значений является выражением. Проще говоря, выражение - это фрагмент кода,
который выдает результат или значение.

### Что такое объект?

Объект представляет собой набор переменных, состояний, функций и, возможно, большего количества
объектов. Объекты используются для организации сущностей в программе и доступа к ним. Для
например, в Klipper macros есть printer объект, к которому прикреплен другой
объект “веер”. У вентилятора есть переменная “speed”, которая используется
как для получения, так и для установки скорости вентилятора. Чтобы получить скорость вентилятора, можно использовать

	printer.fan.speed 
 
### Что такое параметр?

Параметр - это значение, которое используется в качестве входных данных для выполнения
функции. В gcode функцией будет команда gcode, а
параметрами будут положения осей и скорости.

	G1 X100 Y24 Z1 F2000
В других языках программирования, таких как python, функции представлены именем
а параметры заключены в круглые скобки после имени.

	action_respond_info("String Literal")
 
### Что такое условное обозначение?

Аналогично, выражения также могут оценивать две вещи. Условные выражения отвечают на
Yes или No, True илиFalse, 1 или 0 задавайте вопрос, оценивая одну переменную или литерал
по сравнению с другой переменной или литералом. Это “булева” логика, и она лежит в
основе всего программирования.

	Is 15 equal to 12? 
	False

	Is EXTRUDER_TEMP > 100?
	True
Аналогично, функции могут возвращать значение после выполнения, и это значение также можно
сравнивать в выражении.

Там говорится, что у вас есть функция, вызываемая EXTRUDER_PERCENT_TO_TARGET() и она принимает
два параметра. Она возвращает процентное соотношение CURRENT_TEMP к TARGET_TEMP
Is EXTRUDER_PERCENT_TO_TARGET( CURRENT_TEMP, TARGET_TEMP ) > 70? False
Что такое макрос?

Макрос - это сохраненный набор команд, которые могут быть вызваны из одной
команды gcode. Макросы могут вызывать другие макросы или даже самих себя. Макросы можно
рассматривать как функции. По сути, макрос klipper - это
функция.

### Что такое Jinja?

Jinja - это движок для python (основного языка Klipper), который может
брать блок текста и считывать из него элементы программирования. В случае
макросов gcode эти программные элементы применяются в качестве шаблона команды.

Шаблон команды можно рассматривать как абзац из книги "Заполните пробелы".
Например, Mad Libs встречается с Choose Your Own Adventure. Когда вызывается макрос gcode,
полностью считывается и оценивается шаблон команды. gcode, который
передается обратно в klipper, является результатом любых решений, которые были приняты
внутри этого макроса.

### Что такое отложенный gcode?

Отложенный gcode - это макрос, который нельзя вызвать напрямую, но вместо этого вызывается
и выполняется по таймеру с заданным интервалом. Отложенный gcode может выполняться один или
неоднократно.

## Часть 2: Анатомия макроса

### Определение макроса.

Теперь, когда с некоторыми основными концепциями покончено, мы создадим обычный макрос start
print, который вызывается программой slicer при запуске печати. Он переместит
насадку в угол ложа и нарисует линию грунтовки.

В файле конфигурации нам сначала нужно определить макрос. Макросы имеют префикс
gcode_macro далее следует пробел, а затем имя макроса.

	[gcode_macro start_print]
 
Следующее, что необходимо, - это фактический gcode для выполнения. После
объявления макроса нам нужно определить gcode: раздел для макроса. Как только будет выполнен
gcode: добавлен раздел, мы можем поместить gcode в шаблон.

Фактические команды gcode должны иметь отступы, иначе файл конфигурации не загрузится
. Вы можете видеть, что в этом макросе каждая строка прокомментирована, чтобы было понятно ее
назначение.

	[gcode_macro start_print]
	gcode:
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis to travel height
		G1 X0.1 Y20 Z0.2 F5000.0 		# Move to start position
		G1 X0.1 Y200.0 Z0.2 F1500.0 E15 # Draw the first line
		G1 X0.4 Y200.0 Z0.2 F5000.0 	# Move to side a little
		G1 X0.4 Y20 Z0.3 F1500.0 E30 	# Draw the second line
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis up to travel height
  
Затем мы можем вызвать макрос в любое время из терминала или из файла gcode
простым добавлением start_print. Это также может быть включено в раздел слайсера
start-gcode, чтобы он вызывался, когда машина начинает выполнение
файла. Когда файл читается Klipper, Octoprint или чем-то еще, он
перейдет в строку start_print, и эта команда будет заменена на
набор команд в макросе.

## Часть 3: Параметры и основные условные обозначения

Если оси не выровнены или сопло не имеет температуры, оно выйдет из строя, как и
все остальное, из-за проверок безопасности.

Что, если мы захотим включить что-то из этого в мой start_print макрос? Нам
нужно было бы каким-то образом получить значения из слайсера, такие как экструдер и температура слоя, обратно в наш макрос.
Для этого мы можем использовать параметры.

Чтобы добавить параметр для макроса, все, что нам нужно сделать, это сослаться на него. В
шаблонах Jinja2 программные действия должны быть заключены в фигурные
скобки. В этом случае мы просто заменяем имя параметра
на его значение. Параметры, передаваемые макросу gcode, содержатся в params коллекции. Из-за того, как параметры обрабатываются в анализаторе gcode, они должны быть с заглавной буквы при ссылке на них в макросе.

	[gcode_macro start_print]
	gcode:
		M109 S{ params.TOOL_TEMP }		# Heat the tool to temperature and wait
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis to travel height
		G1 X0.1 Y20 Z0.2 F5000.0 		# Move to start position
		G1 X0.1 Y200.0 Z0.2 F1500.0 E15 # Draw the first line
		G1 X0.4 Y200.0 Z0.2 F5000.0 	# Move to side a little
		G1 X0.4 Y20 Z0.3 F1500.0 E30 	# Draw the second line
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis up to travel height
  
Отныне при каждом вызове start_print он { params.TOOL_TEMP } будет заменяться
на любое значение, которое присвоено tool_temp параметру.

	start_print tool_temp=200
 
Если наш слайсер поддерживает переменные в своих шаблонах gcode, таких как варианты Slic3r,
например, мы могли бы заменить 200 на любую переменную, которая есть в
слайсер. Итак, в начальный gcode мы могли бы поместить что-то вроде

	start_print tool_temp=[first_layer_temperature]
 
когда файл gcode записан, программа для нарезки заменяет переменную
[first_layer_temperature] для температуры, которая была указана в
настройках слайсера для этой конкретной нити накала. Это приведет к созданию gcode в выходном
файле, аналогичном

	start_print tool_temp=200	
 
Когда макрос вызывается, 200 возлагается на tool_temp,
параметр. Когда tool_temp переменная используется, он заменяется
за 200.

	M109 S200				# Heat the tool to temperature and wait
 
Это по-прежнему не решает проблему с осями, которые не привязаны друг к другу. Мы могли бы просто
вызвать G28 в начале макроса, но это привело бы к повторному наведению осей
даже если они уже наведены. С помощью макросов мы действительно можем проверить, чтобы
посмотреть, нужно ли нам вернуться домой, используя условное обозначение и ссылаясь на инструментальную головку
объект.

В Jinja2 перед условным обозначением ставится префикс {%, за которым следует тип используемого условного обозначения
, за которым следует выражение, которое будет вычисляться, закрытое с помощью %} В этом случае,
мы хотели бы использовать if оператор. if Оператор - это условное выражение,
которое сравнивает две вещи и приводит к true или “ложному” ответу. Если
результирующий ответ true, то выполняется код в if инструкции,
если это так false, то код игнорируется или else выполняется. Подробнее об этом позже.

У Klipper есть определенные “виртуальные” объекты, доступные макроэкосистеме, так что
такого рода вещи могут быть выполнены. В нашем примере с макросом мы
хотим выяснить, какие оси в данный момент расположены. Для этого нам нужно
сослаться на printer объект. У printer объекта есть поле, называемое
homed_axes который представляет собой строку символов, представляющих каждую ось, которая
в данный момент находится в исходном положении. Таким образом, XY это означало бы, что и X, и Y находятся в исходном положении, а Z - нет.

printer.homed_axes Объект всегда будет содержать оси в порядке XYZ
итак, чтобы проверить, все ли 3 оси выровнены, нам просто нужно убедиться, что
значение printer.homed_axes XYZ равно к,,. Поскольку мы хотим выполнить
действие, если они не включены, нам нужно использовать не равный оператор сравнения
, != .

Простым английским языком мы пытаемся сказать: “Если не установлены все 3 оси, установите их на место”.

В Jinja2 мы выражаем это как

	{% if printer.homed_axes != 'XYZ' %}
		G28			#Home All Axes
	{% endif %}
Условие вводится в первой строке, заключенной в фигурные скобки со знаками
процента. Код для выполнения находится в следующей строке. Наконец, {% endif %}
для закрытия инструкции добавляется тег. Все, что находится между if и endif,
выполняется, если if инструкция выполняет оценку true.

Итак, при вызове макроса, если одна или несколько осей принтера не установлены,
для их установки будет вызван G28.

	[gcode_macro start_print]
	gcode:
		M109 S{params.TOOL_TEMP}		# Heat the tool to temperature and wait
		
		{% if printer.homed_axes != 'XYZ' %}
			G28							#Home All Axes
		{% endif %}
	
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis to travel height
		G1 X0.1 Y20 Z0.2 F5000.0 		# Move to start position
		G1 X0.1 Y200.0 Z0.2 F1500.0 E15 # Draw the first line
		G1 X0.4 Y200.0 Z0.2 F5000.0 	# Move to side a little
		G1 X0.4 Y20 Z0.3 F1500.0 E30 	# Draw the second line
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis up to travel height

## Часть 4: Параметры по умолчанию

Одним из недостатков произвольного ввода параметра в макросе является то, что на него можно
ссылаться без значения. Это может привести к нежелательному поведению или
ошибке во время выполнения, если оно не обрабатывается. Один из способов проверить, завершает ли работу
параметр, - это просто оценить его.

	{% if PA %}
	{% if params.PA %}
Доступ к параметрам Gcode в макросах осуществляется либо путем прямой ссылки на
имя параметра, либо с помощью params коллекции. Есть некоторые
нюансы использования params коллекции в том, что в ней будут только значения, которые
передаются через команду gcode. Принимая во внимание прямую ссылку на
имя параметра может позволить нам получить значение по умолчанию для ‘default_parameter_PA’

Jinja предоставляет нам возможность использовать определенные фильтры для таких вещей, как округление и ввод текста (подробнее
об этом позже). Также существует default() фильтр, который можно использовать вместо
объявления default_parameter_PA.

	{ params.PA|default(.06) }
Итак, если мы передаем параметр a для PA и хотим установить pressure
в нашем макросе start print мы можем проверить наличие параметра, а затем
вызвать SET_PRESSURE_ADVANCE команду.

	SET_PRESSURE_ADVANCE ADVANCE={ params.PA|default(.06) }
В качестве альтернативы вы можете присвоить ему значение по умолчанию, используя default_parameter
параметр конфигурации для макроса gcode.

	[gcode_macro start_print]
	default_parameter_PA: 0.06
	gcode:
Для этого примера мы добавляем Pressure Advance настройку в наш
запуск макроса печати, чтобы можно было установить PA на основе определенной нити накала

	[gcode_macro start_print]
	default_parameter_PA: 0.06
	gcode:
		M109 S{params.TOOL_TEMP}		# Heat the tool to temperature and wait
		
		{% if printer.homed_axes != 'XYZ' %}
			G28							#Home All Axes
		{% endif %}
	
		SET_PRESSURE_ADVANCE ADVANCE={PA}
	
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis to travel height
		G1 X0.1 Y20 Z0.2 F5000.0 		# Move to start position
		G1 X0.1 Y200.0 Z0.2 F1500.0 E15 # Draw the first line
		G1 X0.4 Y200.0 Z0.2 F5000.0 	# Move to side a little
		G1 X0.4 Y20 Z0.3 F1500.0 E30 	# Draw the second line
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis up to travel height

  ## Часть 5: Типы данных, назначения, приведение и область видимости

### Типы данных

Ранее мы обсуждали переменные и объекты и
упоминали "типы”. В мире программирования все, что имеет значение, имеет тип. Тип относится к тому, как это значение хранится в памяти и как оно
используется в программе. Отдельные символы и слова называются

strings. По умолчанию любые параметры, передаваемые в макрос, создаются
в виде строк. Многие значения, доступные в макросе, также являются типами.string

При использовании a string в сравнении или присваивании значение <em>должно</em> быть заключено в кавычки. Допускается использование одинарных или двойных кавычек при условии, что начальная кавычка совпадает с конечной. Итак


	{% if printer.homed_axes != 'XYZ' %}
и

	{% if printer.homed_axes != "XYZ" %}
оба допустимы, но

	{% if printer.homed_axes != "XYZ' %}
нет. Сравнения строк всегда чувствительны к регистру, что означает

	'My Value' is not equal to 'my value'
В дополнение к string, существуют также типы float, и int (плюс многие
другие, но это уже другая тема).

A float - это любое числовое значение, которое не является целым числом (имеет десятичную точку).
Оно называется float как сокращение от "с плавающей запятой”. Плавающая точка означает, что
количество цифр до и после десятичной запятой различается.
Это действительно важно для программы, но не настолько для нас. Все, о чем мы
должны беспокоиться, это о том, что это не целое число.

Если нам нужны только целые числа, мы можем использовать int тип данных.

### Задания

Иногда может потребоваться создать переменную внутри нашего макроса,
которая не передается параметром, или если параметр предоставлен
и мы хотим получить к нему доступ как к определенному типу для области действия нашего макроса.

Для создания новой переменной мы используем выражение Jinja2 set. Итак, если бы мы
хотели создать переменную с именем “toolTemp” и чтобы она была значением
параметра "TOOL_TEMP", мы бы сделали

	{% set toolTemp = params.TOOL_TEMP %}
Это создало бы переменную с именемtoolTemp, и она была бы равна
значению параметра TOOL_TEMP на момент выполнения set операции
. Как упоминалось ранее, параметрами всегда являются string,
поэтому, прежде чем мы сможем произвести какие-либо расчеты или сравнения, нам нужно преобразовать это
во что-то более числовое.

### Кастинг

Приведение относится к изменению одного типа на другой. Переход от int к a
float отлично. int Значение 42, приведенное в качестве float, даст
42.000... Однако переход от a float к an int “усекает”
цифры после запятой, так что 42.9999 во многих42 случаях
вам потребуется округлить число до ближайшего целого
перед кастингом.

Итак, как мы приводим типы? В Jinja2 есть так называемые фильтры. Фильтры
применяются путем указания | (канала), за которым следует тип фильтра. Итак,
чтобы привести наш параметр TOOL_TEMP string в качестве int, мы бы сделали

	params.TOOL_TEMP|int
чтобы округлить a float до ближайшего целого числа для приведения
это как int нам нужно применить round фильтр, который принимает фильтр округления
параметр, который определяет, сколько цифр после десятичной точки в
округлите число до. Итак, чтобы получить переменную, a округленную до ближайшего
целого числа и преобразовать его в int, фильтры будут выглядеть следующим образом

	a|round(0)|int
Почему важны типы? Допустим, в нашем макро "Начать печать" мы хотим предварительно разогреть
нашу кровать и hotend одновременно, но мы хотим добавить что-то вроде таймера ожидания
в конце, чтобы температура слоя успела “впитаться” во всю поверхность слоя.

Мы хотим, чтобы это время рассчитывалось на основе температуры слоя, которая была
при вызове макроса start print, по сравнению с целевой температурой
печати. Если мы сделаем что-то вроде

	{% set dwell = params.BED_TEMP * 3 %} 
Если наш параметр BED_TEMP равен 10, то BED_TEMP * 3 будет 101010
потому что * оператор, применяемый к строковому значению, дублирует это
строковое значение несколько раз. Итак, чтобы умножить температуру кровати на 3, мы должны
сначала преобразовать ее в int.

	{% set dwell = params.BED_TEMP|int * 3 %} 
### Область применения

Любая переменная, которую мы создаем в макросе, существует только в этом макросе и
доступ к ней возможен только в этом макросе. Это называется областью видимости. Есть
некоторые случаи, когда доступ к переменной возможен только из структуры элемента управления
(например, цикл for), и они будут обсуждены позже.

### Сведение воедино

Итак, давайте применим задержку к нашему макросу. Если моя начальная температура слоя
уже достигла целевой температуры, потому что мы предварительно разогревали продукты,
мы можем сказать, что хотим “подержать его” всего 1 минуту.

Если температура слоя в начале выполнения макроса меньше, чем на
20 градусов ниже целевой, мы хотим “подержать его” в течение 5 минут.

	{% set target  = params.BED_TEMP|int %}
	{% set current = printer.heater_bed.temperature %}
	
	{% if current < target - 20 %}
		G4 P{ 5 * 60 * 1000 }       #Milliseconds to dwell
	{% else %}
		G4 P{ 1 * 60 * 1000 }
	{% endif %}

 ## Часть 6: Коллекции

### Что это?

Языки программирования уже давно поддерживают базовые коллекции в виде
массивов. Массив - это отдельная переменная, представляющая местоположение в памяти, которое
было разделено на блоки, к которым можно получить доступ с помощью индекса. Итак, если,
например, нам нужно сохранить 3 точки данных, например, один цвет RGB, мы могли бы
сделать это, создав массив, содержащий 3 элемента. Порядок цветов в
этом массиве будет красным, затем зеленым, затем синим. Доступ к значению для каждого из них
осуществляется путем указания индекса для каждого.

	red   = myColor[0]
	green = myColor[1]
	blue  = myColor[2]
С помощью массивов также можно указать дополнительные измерения. Если бы мы хотели
хранить несколько значений цвета RGB в одном массиве, как для растрового изображения,
мы могли бы определить этот массив со вторым измерением, представляющим строку из
пиксели и значения цвета для каждого пикселя столбца в этой строке. Можно добавить третье измерение
, которое объединяет все строки вместе.

						Row
						|  Column
						|  |  Color
						V  V  V	
	pixel = bitmapArray[2][1][2]
Каждый язык программирования имеет свой собственный специфический способ работы с вещами. Это
подробное описание этих вещей выходит за рамки данного руководства, поскольку
во многих отношениях массивы довольно примитивны по современным стандартам. Важно упомянуть о них
хотя бы потому, что они являются основой для более продвинутых типов “коллекций”
. Многие языки программирования высокого уровня поддерживают их в различных формах, и
python не исключение.

Jinja2 поддерживает 3 готовых типа коллекций: список, кортеж и словарь.
В расширении Python также поддерживает эти типы коллекций, поскольку он написан
поверх Python и в нем много совпадений.

### Списки и кортежи

Списки и кортежи представляют собой упорядоченный ряд значений, хранящихся в одной переменной,
очень похоже на массив, обсуждавшийся ранее. Однако они более продвинуты, чем массив,
поскольку содержат дополнительные методы и функциональность, помимо назначения
и доступа.

В различных языках программирования у нас есть так называемые изменяемые и неизменяемые
объекты. Изменяемый - это одно из тех слов, которые любят использовать умные люди. Это означает
что-то вроде “подлежит изменению”. Изменяемые объекты могут быть изменены
после их создания. Неизменяемые типы, не могут быть изменены.

Объект List в Jinja2 является изменяемым типом, это означает, что его можно изменить после того, как он
был создан. С другой стороны, кортежи нельзя изменить после того, как они
созданы. Оба типа являются итеративными и упорядоченными в том смысле, что при обращении к ним
элемент в позиции [n] всегда будет одним и тем же.

Определить список так же просто, как предоставить разделенный запятыми список значений, которые
заключены в квадратные скобки.

	{% set myList = [ 2, 4, 6, 8, 10] %}
Кортежи объявляются таким же образом, но используются круглые скобки

	{% set myTuple = ( 2, 4, 6, 8, 10) %}
### Словари

Словари немного более продвинутые. Эти типы используют пары <em>ключ-значение</em> для представления своих элементов данных. С каждым элементом в словаре связано 2 элемента, это ключ и значение. Они очень полезны тем, что вы можете иметь одну переменную, представляющую несколько разных объектов с несколькими
разными значениями.



Коллекции также могут быть наборами других коллекций или типов и объектов,
организованных в большую структуру данных.

### Почему все это важно?

Klipper предоставляет printer объект системе макросов. Этот
объект очень полезен для получения различных значений, связанных с текущим состоянием
принтера. На него уже несколько раз ссылались в этом руководстве,
но до сих пор это толком не объяснялось.

## Часть 7: Объект принтера

Многие модули Klipper имеют так называемую оболочку get_status() эти оболочки
представляют собой функции, которые сообщают о состоянии модуля. Например, toolhead
оболочка get_status сообщает о таких вещах, как position, max_velocity и
max_accel. Оболочка get_status добавляется к printer объекту
при запуске Klipper. Перемещаясь по printer иерархии объектов, мы можем получить
всевозможную полезную информацию, которая может быть использована в макросах.

Древовидная структура представляет собой мешанину типов, организованных в различные коллекции. В эти
коллекции часто вложено больше коллекций. Это довольно сложно.

Я написал макрос, помогающий выполнять поиск значений в дереве принтеров
(пример: поиск объектов принтера), поскольку
я никогда не могу вспомнить точные названия чего-либо.

Вы можете видеть на выходе, что printer объект содержит логические значения, значения с плавающей точкой,
строки, кортежи и даже список списков.

printer.firmware_retraction.retract_length			: 0.75
printer.firmware_retraction.unretract_extra_length 	: 0.0
printer.firmware_retraction.unretract_speed 		: 20.0
printer.firmware_retraction.retract_speed 			: 30.0
printer.probe
printer.probe.last_query 							: False
printer.bed_mesh
printer.bed_mesh.mesh_max 							: (275.0, 275.0)
printer.bed_mesh.profile_name 						: default
printer.bed_mesh.mesh_min 							: (25.0, 25.0)
printer.bed_mesh.probed_matrix : 
	[[-0.16875, -0.16375, -0.151875, -0.165625, -0.168125], 
	[-0.1125, 0.04125, -0.063125, -0.05, -0.13875], 
	[0.020625, -0.015, -0.009375, -0.04625, -0.013125], 
	[0.023125, 0.095625, 0.0475, 0.165625, -0.041875], 
	[0.070625, 0.06375, 0.043125, 0.01625, -0.03375]]
printerОбъект является краеугольным камнем для написания полезных макросов из-за данных,
содержащихся в нем.

Допустим, мы на самом деле не хотим вводить это значение опережения давления по умолчанию в
там, поскольку оно уже определено в [extruder]. Мы можем ссылаться на это
значение из нашего макроса следующим образом.

[gcode_macro start_print]
	gcode:
		{% if not params.PA %}
			{% set PA = printer.configfile.settings.extruder.pressure_advance %}
		{% endif %}
	
		M109 S{params.TOOL_TEMP}		# Heat the tool to temperature and wait
		
		{% if printer.homed_axes != 'XYZ' %}
			G28							#Home All Axes
		{% endif %}
	
		SET_PRESSURE_ADVANCE ADVANCE={PA}
	
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis to travel height
		G1 X0.1 Y20 Z0.2 F5000.0 		# Move to start position
		G1 X0.1 Y200.0 Z0.2 F1500.0 E15 # Draw the first line
		G1 X0.4 Y200.0 Z0.2 F5000.0 	# Move to side a little
		G1 X0.4 Y20 Z0.3 F1500.0 E30 	# Draw the second line
		G92 E0 							# Reset Extruder
		G1 Z2.0 F3000 					# Move Z Axis up to travel height
Следует отметить, что configfile дерево содержит как config, так и
settings ветви. Оба дерева будут содержать все значения, которые были считаны из
этого config файла в последний раз, когда klipper считывал его с диска. В settings дереве
все настроенные в данный момент значения будут представлены в виде типизированных значений, где
config в дереве они будут только как strings.

Следует также отметить, что вы не можете изменить ни одно из значений, найденных в
printer объект. Единственный способ что-либо изменить - это использовать доступный gcode
для этого.

Наш макрос start print довольно быстро начнет выглядеть загроможденным,
особенно если мы начнем выполнять сравнения и математические вычисления для различных значений, полученных
из объекта printer. Одна вещь, которую мы можем сделать, чтобы помочь с этим, - назначить
объект printer или определенную его часть локальной переменной, на которую можно
затем ссылаться вместо этого. Это можно сделать в любом месте макроса перед
его первым использованием, но для краткости я лично предпочитаю размещать это вверху.

[gcode_macro start_print]
	gcode:
		{% set config = printer.configfile.settings %}
	
		{% if not params.PA %}
			{% set PA = config.extruder.pressure_advance %}
		{% endif %}
Это особенно полезно, когда макросы начинают усложняться, например, когда
сравниваем положение инструментальной головки с максимальным положением оси

	{% if printer.toolhead.position.z > ( printer.toolhead.axis_maximum.z - 40 ) %}
Это можно было бы сделать немного аккуратнее, назначив положение и ограничение оси
значения переменной и затем оценив их.

[gcode_macro end_print]
	gcode:
		{% set axismax = printer.toolhead.axis_maximum %}
		{% set pos     = printer.toolhead.position     %}
	
		#Move toolhead away from finished print
		{% if pos.z <= ( axismax.z - 40 ) %}
			G1 X10 Y10 Z{ pos.z + 40 }
		{% else %}
			G1 X10 Y10 Z{ axismax.z }
		{% endif %}
